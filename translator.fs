module Stellite.translator 

open Stellite.parser

// Concat a list of strings with a fixed string in between
let rec intersperse i xs = 
    match xs with
    | [] -> ""  
    | [x] -> x 
    | x::y::ys -> x + i + intersperse i (y::ys)

/// Display the declared global variable names
let dispGlobDecl cmds = 
    List.map (function | GlobDecl vs -> vs 
                       | _ -> []) cmds 
    |> List.concat 

/// Display the declared local variable names
let dispThrDecl cmds = 
    List.map (function | ThrDecl vs -> vs 
                           | _ -> []) cmds 
    |> List.concat 

/// Display the declared values
let dispValDecl cmds = 
    List.map (function | ValDecl vs -> vs  
                       | _ -> []) cmds
    |> List.concat 

/// Display the global and thread-local variable names
let dispAllDecl cmds =   
     (dispGlobDecl cmds |> intersperse ", ") + 
     ", " + 
     (dispThrDecl cmds |> intersperse ", ") // + ", " + dispValDecl cmds

/// Match if the command has a global location
let (|HasGloc|_|) = 
  function | Write (x,_) | Read (x,_) | ReadN x | RMW (x,_,_) -> Some x
           | _ -> None 

/// Match if the command has a lloc1
let (|HasLloc1|_|) = 
  function | Write (_,x) | Read (_,x) | RMW (_,x,_) -> Some x
           | _ -> None

/// Match if the command has an lloc2
let (|HasLloc2|_|) = 
  function | RMW (_,_,x) -> Some x
           | _ -> None

/// Generate the name for the action. 
let opName (i,x) = "op" + string i

/// Get the correct Alloy model set for the action. 
let opKind (i,c) = 
    match c with 
    | Write _ -> "Write"
    | Read _ -> "Read"
    | ReadN _ -> "ReadN" 
    | RMW _ -> "RMW" 
    | AssumeEq _ -> "AssmEq" 
    | FenceSC _ -> "FenceSC" 

/// Helper function to convert a sequence of names into an Alloy sequence definition. 
let rec seqDefn names : string = 
    match names with 
    | a :: b :: rest -> " + (" + string a + "->" + string b + ")" + seqDefn (b :: rest) 
    | _ -> "" 


(*********************************************************************
 *  Display functions  
 *********************************************************************) 

let dispSimpPredRelat ((name, cmds) : string * List<Command>) : List<string> =
    let allOps = List.choose (function Op (i,x) -> Some (i,x) | _ -> None) cmds 
    let glocOps = List.choose (fun (i,x) -> (match x with | HasGloc v -> Some (i,v) | _ -> None)) allOps 
    let lloc1Ops = List.choose (fun (i,x) -> (match x with | HasLloc1 v -> Some (i,v) | _ -> None)) allOps 
    let lloc2Ops = List.choose (fun (i,x) -> (match x with | HasLloc2 v -> Some (i,v) | _ -> None)) allOps in 
      [ "pred " + name ] @
      [ "         [ dom : set Action, kind : Action -> Kind," ] @
      [ "           gloc : Action -> Glob, lloc1, lloc2 : Action -> Thr, " ] @
      [ "           sb : Action -> Action, " + (dispGlobDecl cmds |> intersperse ", ") + " : Glob, " 
               + (dispThrDecl cmds |> intersperse ", ") + " : Thr ] { "] @
      [ "  sb in (dom -> dom)" ] @ 
      (if (List.length allOps > 0) then 
        [ "  some disj " + (List.map opName allOps |> intersperse ", ") + " : Action | "]
      else []) @ 
      [ "  { "] @ 
      [ "    dom = " + (List.fold (fun c a -> (opName a) + " + " + c) "" allOps) + "Call + Ret" ] @ 
      [ "    (Call -> Ret)" + (List.map opName allOps |> seqDefn) + " in sb" ] @ 
      (List.map (fun c -> "    " + (opName c) + ".gloc = " + (snd c)) glocOps) @ 
      (List.map (fun c -> "    " + (opName c) + ".lloc1 = " + (snd c)) lloc1Ops) @ 
      (List.map (fun c -> "    " + (opName c) + ".lloc2 = " + (snd c)) lloc2Ops) @ 
      (List.map (fun c -> "    " + (opName c) + " in kind." + (opKind c)) allOps) @ 
      [ "  }"] @  
      [ "}"] 

let dispHarnessPredRelat name decl = 
    [ "// Optimisation name: " + name ] @ 
    [ "pred optPred" ] @
    [ "     [ dom, dom' : set Action," ] @
    [ "       kind, kind' : Action -> Kind,"] @
    [ "       gloc, gloc' : Action -> Glob," ] @ 
    [ "       lloc1, lloc1' : Action -> Thr," ] @
    [ "       lloc2, lloc2' : Action -> Thr," ] @
    [ "       sb, sb' : Action -> Action ] {" ] @ 
    [ "  one Call & (dom + dom')" ] @ 
    [ "  one Ret & (dom + dom')" ] @ 
    [ "  preexecWF[dom, kind, gloc, lloc1, lloc2, sb]" ] @ 
    [ "  preexecWF[dom', kind', gloc', lloc1', lloc2', sb']" ] @ 
    [ "  some disj " + (dispGlobDecl decl |> intersperse ", ") + " : Glob, " + 
             "disj " + (dispThrDecl decl |> intersperse ", ") + " : Thr | {" ] @ 
    [ "    optLHS[dom - Extern, kind, gloc, lloc1, lloc2, sb, " + dispAllDecl decl + "]" ] @ 
    [ "    optRHS[dom' - Extern, kind', gloc', lloc1', lloc2', sb', " + dispAllDecl decl + "]" ] @ 
    [ "  }" ] @ 
    [ "}" ] 


let dispOptPredRelat (depth :int) (filen : string) ((name,decl,lhs,rhs) : string * List<Command> * List<Command> * List<Command>) 
                : List<string> = 
    [ "// Warning: automatically generated file - modifications will be overwritten!" ] @
    [ "// Generated by Stellite from " + filen ] @
    [ "module " + name ] @
    [ "open ../c11Relat" ] @ 
    [ "open ../histRelat" ] @ 
    [ "" ] @ 
    dispHarnessPredRelat name decl @
    [ "" ] @ 
    dispSimpPredRelat ("optLHS", (decl @ lhs)) @ 
    [ "" ] @ 
    dispSimpPredRelat ("optRHS", (decl @ rhs)) @ 
    [ "" ] @ 
    [ "check { histIncl } for " + string depth ] @
    [ " but"] @
    // Constrain the domain of global / local variables to exactly those in the opt definition
    [ "  exactly 1 Call, exactly 1 Ret," ] @ 
    [ "  exactly " + (dispGlobDecl decl |> List.length |> string) + " Glob," ] @
    [ "  exactly " + (dispThrDecl decl |> List.length |> string) + " Thr" ] 


